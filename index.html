<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å…¨æ¯åœ°çƒ v6.1 (ä¼˜åŒ–ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; cursor: none; }
        
        /* ä¿æŒ v6.0 çš„è®¾ç½®ï¼šéšè—è§†é¢‘ä½†ä¿ç•™æ¸²æŸ“èƒ½åŠ› */
        #input_video { 
            position: absolute; top: 0; left: 0; 
            width: 320px; height: 240px; 
            opacity: 0; /* å…³é”®ï¼šä¸å¯è§ä½†å­˜åœ¨ */
            z-index: -1; pointer-events: none;
        }

        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 60%, #000 150%);
        }

        .hud-header {
            position: absolute; top: 20px; left: 20px; pointer-events: auto;
            color: #fff; text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        h1 { margin: 0; font-size: 24px; letter-spacing: 4px; border-bottom: 2px solid #00ffff; padding-bottom: 5px; display: inline-block; font-weight: 300; color: #00ffff;}
        .data-row { font-size: 12px; margin-top: 5px; opacity: 0.8; font-family: 'Courier New', monospace; color: #fff;}
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ä¼˜åŒ– */
        #status-box {
            margin-top: 10px; font-size: 14px; font-weight: bold; color: #aaa;
            border: 1px solid #333; padding: 5px 10px; display: inline-block; background: rgba(0,0,0,0.5);
            transition: color 0.2s, border-color 0.2s;
        }
        
        .city-label {
            position: absolute;
            background: rgba(10, 20, 30, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid #555;
            padding: 8px 12px;
            transform: translate(-50%, -50%);
            display: none; transition: all 0.2s; min-width: 120px; backdrop-filter: blur(4px);
            color: #fff;
        }
        /* ç„å‡†é«˜äº®æ ·å¼ */
        .city-label.hovered {
            background: rgba(0, 60, 40, 0.9); /* å˜ç»¿ä¸€ç‚¹ */
            border-color: #00ff00;
            border-left-color: #00ff00;
            transform: translate(-50%, -50%) scale(1.15);
            z-index: 100;
            box-shadow: 0 0 25px rgba(0,255,0,0.5); /* ç»¿è‰²å…‰æ™• */
        }
        .day-theme { border-left-color: #00ffff; } 
        .night-theme { border-left-color: #ffaa00; } 

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 16px; z-index: 20; background: rgba(0,0,0,0.9); 
            padding: 30px 50px; border: 1px solid #00ffff; box-shadow: 0 0 20px rgba(0,255,255,0.2);
            text-align: center;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">
        SYSTEM INITIALIZING...<br>
        <span style="font-size:12px; color:#aaa; display:block; margin-top:10px;">
            Please Allow Camera Permissions
        </span>
    </div>

    <div id="ui-layer">
        <div class="hud-header">
            <h1>HOLO-EARTH v6.1</h1>
            <div class="data-row">SYSTEM: <span style="color:#00ff00">OPTIMIZED</span></div>
            <div class="data-row">MODE: <span id="mode-text">ORBIT NAVIGATION</span></div>
            <div id="status-box">WAITING FOR HAND...</div>
            <div style="margin-top:5px; font-size:11px; color:#888;">
                æ“ä½œæŒ‡å—: å¼ æ‰‹ç„å‡†(ç»¿) -> æåˆç¡®è®¤(çº¢)
            </div>
        </div>
        <div id="labels-container"></div>
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

<script>
    // --- é…ç½® ---
    const CITIES = [
        { name: "Beijing", lat: 39.9042, lon: 116.4074 },
        { name: "New York", lat: 40.7128, lon: -74.0060 },
        { name: "London", lat: 51.5074, lon: -0.1278 },
        { name: "Tokyo", lat: 35.6762, lon: 139.6503 },
        { name: "Sydney", lat: -33.8688, lon: 151.2093 },
        { name: "Dubai", lat: 25.2048, lon: 55.2708 },
        { name: "Singapore", lat: 1.3521, lon: 103.8198 }
    ];

    // --- 1. Three.js åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000103);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 4.2;

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output_canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    const pivotGroup = new THREE.Group(); 
    scene.add(pivotGroup);
    
    const handGroup = new THREE.Group();
    scene.add(handGroup);
    handGroup.renderOrder = 999; 

    // ç¯å…‰
    scene.add(new THREE.AmbientLight(0x333333));
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
    sunLight.position.set(5, 3, 5);
    scene.add(sunLight);
    scene.add(new THREE.DirectionalLight(0x0088ff, 0.8));

    // --- 2. åœ°çƒæ„å»º ---
    const loader = new THREE.TextureLoader();
    let earthMesh, cloudMesh;
    const EARTH_RADIUS = 1.5;

    async function fetchWeather(city) {
        try {
            const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${city.lat}&longitude=${city.lon}&current_weather=true&timezone=auto`);
            const data = await res.json();
            return data.current_weather;
        } catch (e) { return null; }
    }

    Promise.all([
        new Promise(r => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg', r)),
        new Promise(r => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg', r)),
        new Promise(r => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg', r)),
        new Promise(r => loader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png', r))
    ]).then(tex => {
        const [map, spec, norm, clouds] = tex;
        earthMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_RADIUS, 64, 64),
            new THREE.MeshPhongMaterial({ map, specularMap: spec, normalMap: norm, specular: new THREE.Color(0x333333), shininess: 15 })
        );
        pivotGroup.add(earthMesh);

        cloudMesh = new THREE.Mesh(
            new THREE.SphereGeometry(EARTH_RADIUS + 0.02, 64, 64),
            new THREE.MeshPhongMaterial({ map: clouds, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide })
        );
        pivotGroup.add(cloudMesh);
        
        initLabels();
        document.getElementById('loading').style.display = 'none';
    });

    const glowMesh = new THREE.Mesh(
        new THREE.SphereGeometry(EARTH_RADIUS + 0.2, 64, 64),
        new THREE.ShaderMaterial({
            uniforms: { c: { value: 0.3 }, p: { value: 4.5 }, glowColor: { value: new THREE.Color(0x00aaff) } },
            vertexShader: `varying vec3 vNormal; void main() { vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `uniform vec3 glowColor; uniform float c; uniform float p; varying vec3 vNormal; void main() { float intensity = pow(c - dot(vNormal, vec3(0, 0, 1.0)), p); gl_FragColor = vec4(glowColor, intensity); }`,
            side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true
        })
    );
    scene.add(glowMesh);

    // --- 3. æ ‡ç­¾ç³»ç»Ÿ ---
    const cityData = [];
    let isFocusing = false;
    let hoveredCityIndex = -1; 

    function latLongToVector3(lat, lon, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        return new THREE.Vector3(-(radius * Math.sin(phi) * Math.cos(theta)), radius * Math.cos(phi), radius * Math.sin(phi) * Math.sin(theta));
    }

    function initLabels() {
        const container = document.getElementById('labels-container');
        CITIES.forEach((city, i) => {
            const div = document.createElement('div');
            div.className = 'city-label';
            div.innerHTML = `<span class="city-name">${city.name.toUpperCase()}</span><div class="weather-info" id="w-${i}">Scanning...</div>`;
            container.appendChild(div);
            
            cityData.push({ element: div, localPosition: latLongToVector3(city.lat, city.lon, EARTH_RADIUS), screenPos: {x:0, y:0} });

            fetchWeather(city).then(w => {
                if(w) {
                    const el = document.getElementById(`w-${i}`);
                    const icon = w.is_day ? "â˜€ï¸" : "ğŸŒ™";
                    const tempColor = w.is_day ? "#00ffff" : "#ffaa00";
                    el.innerHTML = `<span style="color:${tempColor}; font-weight:bold">${w.temperature}Â°C</span> ${icon} | ğŸ’¨${w.windspeed}`;
                    div.classList.add(w.is_day ? 'day-theme' : 'night-theme');
                }
            });
        });
    }

    // --- 4. è§†è§‰åŒ–æ‰‹åŠ¿ç³»ç»Ÿ (ä¼˜åŒ–ç‰ˆ) ---
    // å®šä¹‰ä¸‰ç§é¢œè‰²çš„æè´¨ï¼šæ‰«æ(è“)ã€é”å®š(ç»¿)ã€ç‚¹å‡»(çº¢)
    const handMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, depthTest: false }); // é»˜è®¤è“
    const hoverHandMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8, depthTest: false }); // ç„å‡†ç»¿
    const activeHandMat = new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.9, depthTest: false }); // ç‚¹å‡»çº¢
    
    const lineMat = new THREE.LineBasicMaterial({ color: 0x00aaaa, transparent: true, opacity: 0.4, depthTest: false });

    const jointMeshes = [];
    const boneLines = [];
    
    for(let i=0; i<21; i++) {
        const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.015, 8, 8), handMat);
        mesh.renderOrder = 999;
        handGroup.add(mesh);
        jointMeshes.push(mesh);
    }
    
    const bones = [[0,1],[1,2],[2,3],[3,4], [0,5],[5,6],[6,7],[7,8], [0,9],[9,10],[10,11],[11,12], [0,13],[13,14],[14,15],[15,16], [0,17],[17,18],[18,19],[19,20], [5,9],[9,13],[13,17]];
    bones.forEach(pair => {
        const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
        const line = new THREE.Line(geometry, lineMat);
        line.renderOrder = 998;
        handGroup.add(line);
        boneLines.push({ line, p1: pair[0], p2: pair[1] });
    });

    const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,20)]);
    const laserMat = new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0, depthTest: false }); 
    const laserBeam = new THREE.Line(laserGeo, laserMat);
    laserBeam.renderOrder = 997;
    scene.add(laserBeam);

    // --- 5. MediaPipe é€»è¾‘ (æ ¸å¿ƒä¿®æ­£) ---
    let pinchState = false;
    let laserScreenPos = { x: 0, y: 0 };
    let targetRotX = 0, targetRotY = 0;
    let handDetected = false;
    const statusBox = document.getElementById('status-box');

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            handGroup.visible = true;
            const lm = results.multiHandLandmarks[0];

            // æ˜ å°„åæ ‡
            const handZ = -2.0; 
            const aspect = window.innerWidth / window.innerHeight;
            const jointPositions = [];

            lm.forEach((p, i) => {
                const ndcX = (1 - p.x) * 2 - 1; 
                const ndcY = -(p.y * 2 - 1);
                const tanFOV = Math.tan(camera.fov * Math.PI / 360);
                const x = ndcX * (aspect * -handZ * tanFOV); 
                const y = ndcY * (-handZ * tanFOV); 
                
                const vector = new THREE.Vector3(x, y, handZ);
                vector.applyMatrix4(camera.matrixWorld);
                jointMeshes[i].position.copy(vector);
                jointPositions.push(vector);
            });

            // æ›´æ–°éª¨éª¼çº¿
            boneLines.forEach(b => {
                const pos = b.line.geometry.attributes.position.array;
                const p1 = jointPositions[b.p1];
                const p2 = jointPositions[b.p2];
                pos[0] = p1.x; pos[1] = p1.y; pos[2] = p1.z;
                pos[3] = p2.x; pos[4] = p2.y; pos[5] = p2.z;
                b.line.geometry.attributes.position.needsUpdate = true;
            });

            // è®¡ç®—æ¿€å…‰ (ä»5å·å…³èŠ‚å°„å‘8å·å…³èŠ‚)
            const laserStart = jointPositions[5];
            const laserEnd = jointPositions[8];
            const laserDir = new THREE.Vector3().subVectors(laserEnd, laserStart).normalize();
            
            // ç¢°æ’æ£€æµ‹ç‚¹ (2ç±³è¿œå¤„)
            const checkPt = laserStart.clone().add(laserDir.multiplyScalar(2));
            checkPt.project(camera);
            laserScreenPos.x = (checkPt.x * .5 + .5) * window.innerWidth;
            laserScreenPos.y = -(checkPt.y * .5 - .5) * window.innerHeight;

            // ç»˜åˆ¶æ¿€å…‰
            const farPoint = laserStart.clone().add(laserDir.multiplyScalar(20));
            const lPos = laserBeam.geometry.attributes.position.array;
            lPos[0]=laserStart.x; lPos[1]=laserStart.y; lPos[2]=laserStart.z;
            lPos[3]=farPoint.x;   lPos[4]=farPoint.y;   lPos[5]=farPoint.z;
            laserBeam.geometry.attributes.position.needsUpdate = true;
            laserBeam.material.opacity = 0.6;

            // --- çŠ¶æ€åˆ¤å®šé€»è¾‘ (ä¿®æ­£ç‰ˆ) ---
            
            // åˆ¤å®š1: æ˜¯å¦æåˆ (é˜ˆå€¼æ”¶ç´§åˆ°0.04ï¼Œé˜²è¯¯è§¦)
            const p8 = lm[8]; const p4 = lm[4];
            const pinchDist = Math.hypot(p8.x - p4.x, p8.y - p4.y);
            const isPinching = pinchDist < 0.04;

            // åˆ¤å®š2: æ˜¯å¦åœ¨ç„å‡†æŸä¸ªåŸå¸‚?
            const isHovering = hoveredCityIndex !== -1;

            if (isPinching) {
                // [çº¢è‰²çŠ¶æ€] æ‰§è¡Œæ“ä½œ
                jointMeshes.forEach(m => m.material = activeHandMat);
                laserBeam.material.color.setHex(0xff0055);
                laserBeam.material.opacity = 0.8;

                if (!pinchState) { // è§¦å‘ç¬é—´
                    if (isHovering) {
                        flyToCity(CITIES[hoveredCityIndex]);
                        statusBox.innerText = "TARGET LOCKED!";
                        statusBox.style.color = "#ff0055";
                        statusBox.style.borderColor = "#ff0055";
                    } else if (isFocusing) {
                        resetView();
                    }
                }
                
                // å¦‚æœæ²¡æœ‰ç„å‡†åŸå¸‚ï¼Œåˆ™å…è®¸æ‰‹åŠ¨æ‹–æ‹½
                if (!isHovering && !isFocusing) {
                    statusBox.innerText = "MANUAL CONTROL";
                    statusBox.style.color = "#ffaa00";
                    targetRotY = (0.5 - p8.x) * 4;
                    targetRotX = (0.5 - p8.y) * 4;
                }
                
                pinchState = true;

            } else {
                // [éæåˆçŠ¶æ€]
                pinchState = false;
                targetRotX = 0; targetRotY = 0;

                if (isHovering) {
                    // [ç»¿è‰²çŠ¶æ€] ç„å‡†ä¸­ï¼Œå‡†å¤‡å°±ç»ª
                    jointMeshes.forEach(m => m.material = hoverHandMat);
                    laserBeam.material.color.setHex(0x00ff00);
                    laserBeam.material.opacity = 1.0; // äº®ä¸€ç‚¹
                    statusBox.innerText = "READY -> PINCH TO CLICK";
                    statusBox.style.color = "#00ff00";
                    statusBox.style.borderColor = "#00ff00";
                } else {
                    // [é’è‰²çŠ¶æ€] æ‰«æä¸­
                    jointMeshes.forEach(m => m.material = handMat);
                    laserBeam.material.color.setHex(0x00ffff);
                    statusBox.innerText = "SCANNING...";
                    statusBox.style.color = "#aaa";
                    statusBox.style.borderColor = "#333";
                }
            }

        } else {
            handDetected = false;
            handGroup.visible = false;
            laserBeam.material.opacity = 0;
            statusBox.innerText = "NO HAND SIGNAL";
            statusBox.style.color = "#555";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const videoElement = document.getElementById('input_video');
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    
    cameraUtils.start().catch(e => {
        document.getElementById('loading').innerHTML = `<span style="color:red">Camera Error</span><br>Use HTTPS or localhost`;
    });

    // --- 6. é£å…¥ä¸æ¸²æŸ“ ---
    function flyToCity(city) {
        if (isFocusing) return;
        isFocusing = true;
        document.getElementById('mode-text').innerText = `TARGET: ${city.name.toUpperCase()}`;
        document.getElementById('mode-text').style.color = "#ffaa00";
        
        const targetRotY = -city.lon * (Math.PI / 180) - Math.PI / 2;
        const targetRotX = city.lat * (Math.PI / 180);

        new TWEEN.Tween(pivotGroup.rotation).to({ x: targetRotX, y: targetRotY }, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
        new TWEEN.Tween(camera.position).to({ z: 2.0 }, 1500).easing(TWEEN.Easing.Cubic.InOut).start();
    }

    window.resetView = function() {
        isFocusing = false;
        document.getElementById('mode-text').innerText = "ORBIT NAVIGATION";
        document.getElementById('mode-text').style.color = "#fff";
        new TWEEN.Tween(camera.position).to({ z: 4.2 }, 1200).easing(TWEEN.Easing.Cubic.Out).start();
    };

    function updateLabelsAndCollision() {
        if (!earthMesh) return;
        pivotGroup.updateMatrixWorld(); 
        hoveredCityIndex = -1; 

        cityData.forEach((city, index) => {
            const tempV = city.localPosition.clone().applyMatrix4(pivotGroup.matrixWorld);
            const normal = tempV.clone().sub(pivotGroup.position).normalize();
            const viewDir = camera.position.clone().sub(tempV).normalize();
            
            if (normal.dot(viewDir) > 0.1) { 
                city.element.style.display = 'block';
                const p = tempV.clone().project(camera);
                const x = (p.x * .5 + .5) * window.innerWidth;
                const y = (p.y * -.5 + .5) * window.innerHeight;
                
                city.element.style.left = `${x}px`;
                city.element.style.top = `${y - 30}px`;
                city.element.style.opacity = isFocusing ? 0.3 : 1.0;

                // æ ¸å¿ƒä¼˜åŒ–ï¼šç¢°æ’æ£€æµ‹åŠå¾„æ‰©å¤§åˆ° 80pxï¼Œæ›´å®¹æ˜“é€‰ä¸­
                const dx = x - laserScreenPos.x;
                const dy = (y - 30) - laserScreenPos.y;
                if (handDetected && Math.hypot(dx, dy) < 80 && !isFocusing) {
                    city.element.classList.add('hovered');
                    hoveredCityIndex = index; // è®°å½•å½“å‰ç„å‡†çš„åŸå¸‚
                } else {
                    city.element.classList.remove('hovered');
                }

            } else {
                city.element.style.display = 'none';
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        TWEEN.update(time);

        if (!isFocusing) {
            pivotGroup.rotation.y += targetRotY * 0.02;
            pivotGroup.rotation.x += targetRotX * 0.02;
            if (targetRotX === 0 && targetRotY === 0) pivotGroup.rotation.y += 0.0005;
        }

        if(cloudMesh) cloudMesh.rotation.y += 0.0003;
        
        updateLabelsAndCollision();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>